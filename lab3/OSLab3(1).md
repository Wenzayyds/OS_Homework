# Lab3
## 实验目的
* 了解虚拟内存的Page Fault异常处理实现
* 了解页替换算法在操作系统中的实现
* 学会如何使用多级页表，处理缺页异常（Page Fault），实现页面置换算法。

## 练习1：理解基于FIFO的页面替换算法
* ##### 换入过程 
首先，在页面转入之前，由trap.c中的trap函数捕获并抛出异常，而后由exception_handler函数按照异常类型进行分发，随后将异常地址和原因由pgfault_handler函数传给vmm.c中的do_pgfault函数：首先在mm_struct中找出该虚拟地址所在的vma（调用函数find_vma）以判断该虚拟地址是否可用，如果可用则判断其访问/写使能，使用ROUNDDOWN函数对齐地址；其次通过get_pte函数找到该地址对应的页表项（未找到则建立新的页表），由于先前在init.c中调用过swap_init()，根据其返回的swap_init_ok变量，若初始化成功，即该变量值为1，则调用swap_in函数，从磁盘中读取所需页（调用alloc_page()函数）进入内存；然后调用swap_insert函数更新页表、插入新的页表项并建立起物理地址与虚拟地址的映射；最后调用swap_map_swappable函数将该页面标记为可换出，然后退出do_pgfault函数。
* ##### 换出过程
该框架中采用消极换出策略，swap_init()中确定了使用的算法为FIFO，使用swap_manager_fifo结构体，调用了初始化函数init来对置换进行初始化，也声明/初始化了swap_out_victim函数和pra_list_head队列等。在alloc_pages函数中，首先判断内存中物理页是否足够，若不够则需要换出其他页面，此时若需要的页数大于一，则退出循环，需要的页数为一时，调用swap_out函数：遍历当前页表中的页，调用swap_out_victim判断是否有可以换出去的界面（这个被换出去的页是在pra_list_head队列中的最前面的未被使用的页，即fifo算法），如果有则返回该物理页面，获取其虚拟地址和页表项，再将该物理页写出到硬盘交换区，刷新TLB退出swap_out函数。全部完成后后退出alloc_pages函数。


## 练习2：深入理解不同分页模式的工作原理
三种分页模式sv32、sv39、sv48的虚拟地址位数不同，分别对应二级页表、三级页表、四级页表。get_pte()函数用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。在sv39的get_pte()中，分别进行了两次找到下一级页表的操作，因此是两段形式类似的代码，最终在最后一级页表找到了对应的页表项。同理，sv32的二级页表只需要一段这样的代码，sv48的四级页表则需要三段类似代码。  
目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，这种写法的优点在于精简程序，增加可读性和减少开销，否则需要再声明用于分配页表项的函数、再进行调用，这样就让代码结构更加复杂，所以将两种功能合并在一起更好；但是如果涉及到多级页表，重复次数过多也会显得函数冗余，这种情况下将两种功能拆分会更好。

## 练习3：给未被映射的地址映射上物理页

* do_pgfault()函数的实现思路：
  该函数主要完成的是具体的页访问异常处理工作，传入的参数为应用程序虚拟存储总管mm、错误码error_code和具体出错的虚拟地址addr。
  给出的代码已经实现已经完成了参数检查及错误检查等流程，剩下的根据注释不难完成：
  * 用虚拟地址addr索引页目录表和页表，得到对应的页表项。这时要分两种情况讨论：
    1.页表项为0时，说明系统尚未为虚拟地址addr分配物理页，因此需要申请分配一个物理页,设置页目录表和页表，以建立虚拟地址addr到物理页的映射；最后，设置该物理页为swappable(由pgdir_alloc_page函数实现)。
    ```c
    if (*ptep == 0) {
        if (pgdir_alloc_page(mm->pgdir, addr, perm) == NULL) {
            cprintf("pgdir_alloc_page in do_pgfault failed\n");
            goto failed;
        }
    }
    ```
    2.页表项不为0时，又出现缺页异常，说明系统已建立虚拟地址addr到物理页的映射，但对应物理页已经被换出到磁盘中。因此需要：
    * 申请分配一个物理页
    * 将换出到磁盘中的那个页面的内容写到该物理页中
    * 建立虚拟地址addr到物理页的映射
    * 设置该物理页为swappable.
    ```c
    if((ret = swap_in(mm,addr,&page))!=0)
    {
        cprintf("swap_in in do_pgfault failed\n");
        goto failed;
    }
    page_insert(mm->pgdir, page, addr, perm);
    swap_map_swappable(mm, addr, page, 1);
    page->pra_vaddr = addr;
    ```
* Q1：请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。 
Ans：页替换涉及到换入换出，换入时需要将某个虚拟地址vaddr对应于磁盘的一页内容读入到内存中，换出时需要将某个虚拟页的内容写到磁盘中的某个位置。而页表项可以记录该虚拟页在磁盘中的位置，为换入换出提供磁盘位置信息。页目录项则是用来索引对应的页表。
* Q2：如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？
Ans：
    * 关中断
    * 保护现场。包括：将页访问异常的错误码压入内核栈的栈顶、将导致页访问异常的虚拟地址记录在cr2寄存器中、保存状态寄存器PSW及断点等。
    * 根据中断源，跳转到缺页服务例程

* Q3：如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？
    Ans：有关系，数据结构page是最低级的页表，目录项是一级页表，存储的内容是页表项的起始地址（二级页表），而页表项是二级页表，存储的是每个页表的开始地址，这些内容之间的关系时通过线性地址高低位不同功能的寻址体现的。

## 练习4：补充完成Clock页替换算法

* swap_clock的实现思路：

    * init_mm初始化函数实现思路与swap_fifo的实现思路基本一致，首先初始化pra_list_head为空链表，然后初始化当前指针curr_ptr指向pra_list_head，表示当前页面替换位置为链表头，之后将mm的私有成员指针指向pra_list_head，用于后续的页面替换算法操作。
        ```c
        list_init(&pra_list_head);
        curr_ptr = &pra_list_head;
        mm->sm_priv = &pra_list_head;
        ```
    * map_swappable实现思路与fifo的实现思路中，将页面page插入到页面链表pra_list_head的末尾的操作都一样，只是需要将页面的visited标志置为1，表示该页面已被访问。
        ```c
        page->visited = 1;
        ```
    * swap_out_victim实现思路为遍历页面链表pra_list_head，查找最早未被访问页面，为了打印出该页面的地址信息我们使用curr_ptr去遍历页面链表，在扫描到第一个未被访问的页面后打印curr_ptr，将该页面从页面链表中删除，并将当前page赋给ptr_page作为换出页面
        ```c
        if(!page->visited)
        {
            cprintf("curr_ptr 0x%016llx\n",curr_ptr);
            list_del(curr_ptr);
            *ptr_page = page;
            break;
        }
        ```

        如果当前页面已被访问，则将visited标志置0，表示该页面已被重新访问,方便下一轮遍历时pick一个页面。
        ```c
        else
        {
            page->visited = 0;
        }
        ```

        但要记得如果遍历到head节点要跳过，因为此处没有page。
        ```c
        if(curr_ptr == head)
        {
            continue;
        }
        ```  
        

* Q1:比较Clock页替换算法和FIFO算法的不同
    Ans:  

    1.工作原理：
    * FIFO算法：根据页面进入内存的顺序，选择最先进入内存的页面进行置换。因此，该算法具有先进先出的特点。
    * Clock算法：将所有页面组成一个环形链表，每次需要置换页面时，从当前指针位置开始，扫描链表，选择最早不被访问的页面进行置换。当然，如果第一遍扫描没有找到可以被置换的页面，那么第二遍就会回到指针之前的位置再次扫描，直到找到为止。


    2.算法复杂度：
    * 相对于FIFO算法而言，Clock算法的实现复杂度要稍微高一些，因为涉及到了指针的移动以及对页面访问情况的维护和更新。

    3.页面置换效率：
    * 在缓存命中率低的情况下，FIFO算法的效率可能会很差，因为它只依赖于页面进入内存的顺序，而忽略了页面的访问频率和重要性。
    * 相比之下，Clock算法在考虑页面的使用情况的基础上，更具有实际应用的价值。
## 练习5：阅读代码和实现手册，理解页表映射方式相关知识
页表是一个存储物理页地址的表。CPU在取指令或者取数据的时候使用的是虚拟地址，为了能够从内存中取得数据，需要将虚拟地址转换为物理地址，虚拟地址和物理地址之间的映射关系就保存在页表中。每个进程都有自己的页表。页表的映射方式主要有两种：单级页表和多级页表。  
单级页表就是用一个页表完成所有物理地址的映射。由于只有一个页表，所以在进程创建时需要为可能用到的所有的页表项分配空间，无论事实上有没有使用这块物理内存。  
而多级页表可以在使用时根据内存的占用为进程分配页表空间，可以实现按需分配而不是预先全部分配。 

多级页表的映射方式如下图所示：  
![Alt text](image.png)
* ##### 单级页表  
* 缺点  
1. 操作系统为每个进程分配固定大小的空间作为页表，这个固定大小的空间必须能覆盖所有页表项，因为操作系统事先并不知道进程到底需要访问多大的主存，不能实现按需分配页表空间。当虚拟内存非常大的时候，页表需要的物理内存也会变得非常大。  
2. 如果使用了快表，由于TLB缓存有限，虚拟内存很大，导致TLB无法缓存最近使用的所有页表项，查询转换速率降低。  
* 优点  
1. 单级页表的实现方式简单，仅需要维护一个页表即可。
2. 访问物理地址时只需要查询一级页表，无需其他查找操作，查询效率高。
* ##### 多级页表
* 优点
1. 可以使得页表在内存中离散存储。多级页表实际上是增加了索引，有了索引就可以定位到具体的项。使用一页来存放页目录项，页表项存放在内存中的其他位置，不用保证页目录项和页表项连续。
2. 适用于大内存空间，多级页表通过只为进程实际使用的那些虚拟地址内存区请求页表来减少内存使用量，提高内存利用率。
3. 灵活，可以通过调整页表级别和页表大小满足不同内存空间需求。
* 缺点
1. 实现方式复杂，需要维护多个页表。并且还要实现页表之间的查找功能。
2. 由于需要在多个级别的页表间查找，访问次数多，耗时。
3. 当进程使用的物理内存接近物理内存大小时，由于需要维护多个页表，占用内存较多。

## 知识点
* 按需分页：虚拟地址可以使得软件在没有访问某虚拟内存地址时不分配具体的物理内存，只有在实际访问某虚拟内存地址时，操作系统再动态地分配物理内存，建立虚拟内存到物理内存的页映射关系。
* 页面的换入换出：把不经常访问的数据所占的内存空间临时写到硬盘上，这样可以腾出更多的空闲内存空间给经常访问的数据；当CPU访问到不经常访问的数据时，再把这些数据从硬盘读入到内存中。这种内存管理技术给了程序员更大的内存“空间”，从而可以让更多的程序在内存中并发运行。
* 传输数据时只允许以磁盘扇区为数据传输的基本单位，也就是一次传输的数据必须是512字节的倍数，并且必须对齐。
* 在 sv39中，定义物理地址(Physical Address)有56位，而虚拟地址(Virtual Address)有39位。不论是物理地址还是虚拟地址，最后12位表示的是页内偏移，也就是这个地址在它所在页帧的什么位置（同一个位置的物理地址和虚拟地址的页内偏移相同）。除了最后12位，前面的部分表示的是物理页号或者虚拟页号。
* 缺页异常：CPU访问的虚拟地址时， MMU没有办法找到对应的物理地址映射关系，或者与该物理页的访问权不一致而发生的异常。
* ucore 对于页面置换机制目前大致有两种策略，即积极换出策略和消极换出策略。  
积极换出策略是指操作系统周期性地（或在系统不忙的时候）主动把某些认为“不常用”的页换出到硬盘上，从而确保系统中总有一定数量的空闲页存在，这样当需要空闲页时，基本上能够及时满足需求；  
消极换出策略是指只有当试图得到空闲页时，发现当前没有空闲的物理页可供分配，这时才开始查找“不常用”页面，并把一个或多个这样的页换出到硬盘上。
* 页面替换算法：
  1. 先进先出(First In First Out, FIFO)页替换算法：该算法总是淘汰最先进入内存的页，即选择在内存中驻留时间最久的页予以淘汰。
  2. 最久未使用(least recently used, LRU)算法：利用局部性，通过过去的访问情况预测未来的访问情况，比较当前内存里的页面最近一次被访问的时间，把上一次访问时间离现在最久的页面置换出去。
  3. 时钟（Clock）页替换算法：是 LRU 算法的一种近似实现。时钟算法需要在页表项（PTE）中设置了一位访问位来表示此页表项对应的页当前是否被访问过。时钟页替换算法在本质上与 FIFO 算法是类似的，不同之处是在时钟页替换算法中跳过了访问位为 1 的页。